## Queue 안의 스케줄링
### SJF ( Shortest Job First )
SJF 기법은 수행시간이 가장 짧은 프로세스부터 순서대로 수행을 해주는 방식으로
Waiting Time 측면에서는 가장 적절한 스케줄링 기법입니다.

이러한 스케줄링 기법을 구현하기 위해 데이터가 들어 있는 배열을 받았을 경우, 배열을 작업 시간을 대상으로 하여 작업 시간이 짧은 프로세스가 가장
앞에 오도록 정렬을 해 주었습니다. 이 후 프로세스의 ID를 작업 시간만큼 출력해 주도록 구현하였습니다.

### Round-Robin
Round-Robin 기법은 정해진 Time Quantum 만큼만 CPU를 할당하고 작업이 완료되지 않으면 Ready queue에 넣어주는 방식의 스케줄링 기법입니다. 프로세스들이 time Quantum 만큼 작업이 끝난 후에는 ready queue에서 순서대로 빼내 주며 위와 같은 방식을 반복하게 됩니다. 저는 Time Quantum의 기준을 5로 잡아 주었습니다.

이러한 스케줄링 기법을 구현하기 위해 자료구조 <queue>를 구현하여 주고, 해당 프로세스의 작업 시간이 time quantum보다 작다면 작업 시간만큼 해당 process ID를 출력해 주고 time quantum 보다 크다면 time quantum만큼 process ID를 출력해 주고 작업시간과 time quantum의 차이만큼 <queue>에 enqueue해 주었습니다. 이 후 <queue>가 빌 때까지 <queue>에서 하나를 dequeue해서 위와 같은 형식을 반복해 주었습니다.

### Priority
Priority 기법은 각 프로세스에 우선순위가 부여되게 되고, 이에 알맞은 순서로 process를 수행해 주는 방식의 스케줄링 기법입니다.

이러한 스케줄링 기법을 구현하기 위해 데이터가 들어가 있는 배열을 받았을 경우 데이터들의 우선순위에 따라 배열을 정렬해 주었습니다. 후에 우선순위에 맞게 정렬된 배열에서 프로세스들의 작업 시간만큼 process ID를 출력해 주었습니다.

### ★ 나만의 기법 Waiting Time Ratio (WTR)
SJF는 waiting time의 기준에서 가장 효율적인 스케줄링 방식으로 알고 있습니다. 하지만 작업시간이 긴 프로세스는 한없이 뒤로 밀리는 Starvation 현상이 발생할 수 있습니다. 저는 이러한 starvation 현상을 조금이라도 완화시킬 방법을 생각해 보다가 이와 같은 스케줄링 알고리즘을 구상하였습니다. 오직 작업 시간을 기준으로 하여 스케줄링 하는 SJF의 방식에 waiting time의 비율을 신경 쓰도록 하여 주었습니다. 우선순위를 정할 때 {(대기 시간 + 작업 시간)/작업시간}의 값이 큰 프로세스에 우선순위를 높게 부여하여 주었습니다. 이와 같은 방식으로 우선순위를 부여한 결과 starvation은 완화되고 조금 더 waiting time에 비중을 둔 스케줄링 기법을 구현할 수 있었습니다.

이러한 스케줄링 기법을 구현하기 위해 데이터에서 프로세스의 {(대기시간 + 작업시간)/작업시간}의 값을 기준으로 배열을 정렬해 줍니다. 이 후 이 비율 값이 큰 순서대로 정렬되어 있는 배열에서 해당 프로세스의 작업 시간만큼 process ID를 출력해 주도록 구현하였습니다.

## Queue 간의 스케줄링

- Input
쓰레드를 통해 queue간의 스케줄링에서 사용할 우선순위를 입력 받습니다.

- Priority
Queue 간의 스케줄링 방식으로는 Priority 방식을 선택하였습니다. Queue 안에서의 스
케줄링 방식과 같이 queue 간에 우선순위를 부여하여 우선순위가 높은 순서대로 queue
를 수행시켜 주었습니다.

for문을 통해 우선순위에 맞게 queue들을 수행시켜 주었습니다.

## 쓰레드 동기화 - Semaphore 이용

쓰레드를 사용하다 보면 쓰레드 마다 알고리즘의 속도가 다르고 모든 수행 시간이 다르기 때문에 모두 한번에 시행되는 쓰레드의 특성상 매번 다른 값이 출력이 되는 경우가 발생할 수 있습니다. 이러한 경우를 사전에 예방하고 queue간의 스케줄링을 통해 올바른 순서로 쓰레드가 수행되 도록 하기 위해 동기화를 해주어야 합니다. 이는 semaphore라고도 하는데 이를 통해 쓰레드의 수행을 제어하여 공유변수의 접근과 쓰레드의 수행들을 제어하게 됩니다. 저는 총 5개의 semaphore를 생성하여 Input을 제외한 모든 쓰레드에 수행을 제어하였습니다. 모두 binary semaphore로써 0으로 초기화 시켜주었습니다. 이 후에 Input을 받는 쓰레드가 수행이 끝나게 되면 sem_post()를 통해 queue 간의 스케줄링을 담당하는 쓰레드를 수행시켜 주었습니다. queue간의 스케줄링 쓰레드는 for 문을 돌며 우선순위에 맞는 *쓰레드들의 semaphore를 sem_post()를 통해 수행시켜 주었습니다. 이 때 한가지 유의할 점은 해당 쓰레드가 끝나기 전에 queue간의 스케줄링 스레드의 for문이 한번 더 돌아 다른 쓰레드 또한 같이 실행되는 경우가 있을 수 있습니다. 이러한 경우를 방지하기 위해 저는 for문이 끝날 때 마다 queue간의 스케줄링을 잠시 멈추기 위해 sem_wait()함수를 사용하여 주었고, 위의 *쓰레드가 수행이 종료되었을 때 sem_post()를 통해 다시 queue간의 스케줄링 쓰레드가 수행되도록 해 주었습니다. 이와 같이 semaphore를 통해 쓰레드들의 수행을 제어하고 공유변수 접근을 막음으로써 정상적인 결과 값을 출력해 낼 수 있었습니다
